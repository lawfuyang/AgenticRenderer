/*
 * RTXDIBuildLocalLightPDF.hlsl
 *
 * Standalone compute shader that fills mip 0 of the local-light PDF texture.
 * Each texel at position (x,y) represents the sampling weight (luminance of
 * pre-computed radiance) of the local light whose index maps to (x,y) via
 * the Z-curve (Morton code) ordering used by RTXDI.
 *
 *   lightIndex = RTXDI_ZCurveToLinearIndex(texelPos)
 *   weight     = Luminance(light.color * light.intensity)
 *
 * Texels that fall outside the valid light index range are written as 0.
 * The mip chain is then generated by RTXDIGeneratePDFMips.hlsl so that
 * RTXDI_PresampleLocalLights can do hierarchical power-importance sampling.
 *
 * Must run every frame — light radiance can change between frames.
 *
 * Dispatch: (ceil(texWidth / 8), ceil(texHeight / 8), 1)
 *
 * Note: This shader does NOT include RTXDIApplicationBridge.hlsli to avoid
 * having both the bridge's UAVs (u0-u3) and this shader's PDF UAV (u4) all
 * active at the same time while the PDF texture is in UAV state.  Resources
 * are declared manually with the same register slots the bridge uses, so a
 * single matching binding set works for both this pass and the shared passes.
 */

#include "ShaderShared.h"
#include "CommonLighting.hlsli"

// ---- Resources (match register slots used by RTXDIApplicationBridge.hlsli) ----
cbuffer RTXDICBuf : register(b1)
{
    RTXDIConstants g_RTXDIConst;
};

StructuredBuffer<GPULight>  g_Lights    : register(t6);   // same as bridge
RWTexture2D<float>          g_PDFMip0   : register(u4);   // mip 0 of the PDF texture

// ---- RTXDI Z-curve utility ----
// Bring in RTXDI_ZCurveToLinearIndex without pulling in the full SDK.
#include "Rtxdi/Utils/Math.hlsli"

// ============================================================================
[numthreads(8, 8, 1)]
void CSMain(uint2 gid : SV_DispatchThreadID)
{
    // Bounds check against mip-0 dimensions.
    if (any(gid >= g_RTXDIConst.m_LocalLightPDFTextureSize))
        return;

    // Map texel position → local-light index via Z-curve.
    const uint lightIndex = RTXDI_ZCurveToLinearIndex(gid);

    float weight = 0.0f;
    if (lightIndex < g_RTXDIConst.m_LocalLightCount)
    {
        const uint  globalIndex = lightIndex + g_RTXDIConst.m_LocalLightFirstIndex;
        const GPULight gl       = g_Lights[globalIndex];

        // Pre-computed radiance depends on light type (same logic as RAB_LoadLightInfo).
        // For the PDF we only need relative luminance, so we use color * intensity.
        // Sky-adjusted sun radiance is expensive to compute here; the sun is an
        // infinite light anyway and is handled by a separate path (not presampled).
        const float3 radiance = gl.m_Color * gl.m_Intensity;
        weight = max(Luminance(radiance), 1e-8f); // small epsilon: never fully zero
    }

    g_PDFMip0[gid] = weight;
}
